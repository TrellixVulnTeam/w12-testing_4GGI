"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppMigrator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const linter_1 = require("@nrwl/linter");
const generators_1 = require("@nrwl/workspace/generators");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const path_1 = require("path");
const e2e_migrator_1 = require("./e2e.migrator");
const project_migrator_1 = require("./project.migrator");
class AppMigrator extends project_migrator_1.ProjectMigrator {
    constructor(tree, options, project) {
        super(tree, options, project, 'apps');
        this.e2eMigrator = new e2e_migrator_1.E2eProjectMigrator(tree, options, project);
    }
    migrate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.e2eMigrator.migrate();
            this.moveProjectFiles();
            yield this.updateProjectConfiguration();
            this.updateTsConfigs();
            this.updateEsLintConfig();
        });
    }
    validate() {
        var _a;
        const result = [];
        if (this.projectConfig.targets.lint &&
            this.projectConfig.targets.lint.executor !==
                '@angular-eslint/builder:lint') {
            result.push({
                message: `The "lint" target is using an unsupported builder "${this.projectConfig.targets.lint.executor}".`,
                hint: `The supported builder is "@angular-eslint/builder:lint".`,
            });
        }
        result.push(...((_a = this.e2eMigrator.validate()) !== null && _a !== void 0 ? _a : []));
        return result.length ? result : null;
    }
    moveProjectFiles() {
        var _a;
        // it is not required to have a browserslist
        this.moveProjectRootFile((0, devkit_1.joinPathFragments)(this.project.oldRoot, 'browserslist'), false);
        this.moveProjectRootFile((0, devkit_1.joinPathFragments)(this.project.oldRoot, '.browserslistrc'), false);
        this.moveFilePathsFromTargetToProjectRoot(this.projectConfig.targets.build, ['tsConfig', 'webWorkerTsConfig', 'ngswConfigPath']);
        if (this.projectConfig.targets.test) {
            this.moveFilePathsFromTargetToProjectRoot(this.projectConfig.targets.test, ['karmaConfig', 'tsConfig', 'webWorkerTsConfig']);
        }
        else {
            // there could still be a karma.conf.js file in the root
            // so move to new location
            const karmaConfig = (0, devkit_1.joinPathFragments)(this.project.oldRoot, 'karma.conf.js');
            if (this.tree.exists(karmaConfig)) {
                this.logger.info('No "test" target was found, but a root Karma config file was found in the project root. The file will be moved to the new location.');
                this.moveProjectRootFile(karmaConfig);
            }
        }
        if (this.projectConfig.targets.server) {
            this.moveProjectRootFile(this.projectConfig.targets.server.options.tsConfig);
        }
        if (this.projectConfig.targets.lint) {
            this.moveProjectRootFile((_a = this.projectConfig.targets.lint.options.eslintConfig) !== null && _a !== void 0 ? _a : (0, devkit_1.joinPathFragments)(this.project.oldRoot, '.eslintrc.json'));
        }
        else {
            // there could still be a .eslintrc.json file in the root
            // so move to new location
            const eslintConfig = (0, devkit_1.joinPathFragments)(this.project.oldRoot, '.eslintrc.json');
            if (this.tree.exists(eslintConfig)) {
                this.logger.info('No "lint" target was found, but an ESLint config file was found in the project root. The file will be moved to the new location.');
                this.moveProjectRootFile(eslintConfig);
            }
        }
        this.moveDir(this.project.oldSourceRoot, this.project.newSourceRoot);
    }
    updateProjectConfiguration() {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.projectConfig.root = this.project.newRoot;
            this.projectConfig.sourceRoot = this.project.newSourceRoot;
            this.convertBuildOptions(this.projectConfig.targets.build.options);
            Object.values((_a = this.projectConfig.targets.build.configurations) !== null && _a !== void 0 ? _a : {}).forEach((config) => this.convertBuildOptions(config));
            if (this.projectConfig.targets.test) {
                const testOptions = this.projectConfig.targets.test.options;
                testOptions.main =
                    testOptions.main && this.convertAsset(testOptions.main);
                testOptions.polyfills =
                    testOptions.polyfills && this.convertAsset(testOptions.polyfills);
                testOptions.tsConfig = (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.spec.json');
                testOptions.karmaConfig = (0, devkit_1.joinPathFragments)(this.project.newRoot, 'karma.conf.js');
                testOptions.assets =
                    testOptions.assets &&
                        testOptions.assets.map((asset) => this.convertAsset(asset));
                testOptions.styles =
                    testOptions.styles &&
                        testOptions.styles.map((style) => this.convertAsset(style));
                testOptions.scripts =
                    testOptions.scripts &&
                        testOptions.scripts.map((script) => this.convertAsset(script));
            }
            if (this.projectConfig.targets.lint) {
                this.projectConfig.targets.lint.executor = '@nrwl/linter:eslint';
                const lintOptions = this.projectConfig.targets.lint.options;
                lintOptions.eslintConfig =
                    lintOptions.eslintConfig &&
                        (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(lintOptions.eslintConfig));
                lintOptions.lintFilePatterns =
                    lintOptions.lintFilePatterns &&
                        lintOptions.lintFilePatterns.map((pattern) => this.convertPath(pattern));
                const eslintConfigPath = (_b = lintOptions.eslintConfig) !== null && _b !== void 0 ? _b : (0, devkit_1.joinPathFragments)(this.project.newRoot, '.eslintrc.json');
                const eslintConfig = (0, devkit_1.readJson)(this.tree, eslintConfigPath);
                if ((0, linter_1.hasRulesRequiringTypeChecking)(eslintConfig)) {
                    lintOptions.hasTypeAwareRules = true;
                }
            }
            if (this.projectConfig.targets.server) {
                const serverOptions = this.projectConfig.targets.server.options;
                this.convertServerOptions(serverOptions);
                Object.values(this.projectConfig.targets.server.configurations).forEach((config) => this.convertServerOptions(config));
            }
            (0, devkit_1.updateProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig));
            yield (0, generators_1.convertToNxProjectGenerator)(this.tree, {
                project: this.project.name,
                skipFormat: true,
            });
        });
    }
    updateTsConfigs() {
        const rootTsConfigFile = (0, typescript_1.getRootTsConfigPathInTree)(this.tree);
        const projectOffsetFromRoot = (0, devkit_1.offsetFromRoot)(this.projectConfig.root);
        this.updateTsConfigFile(this.projectConfig.targets.build.options.tsConfig, rootTsConfigFile, projectOffsetFromRoot);
        if (this.projectConfig.targets.test) {
            this.updateTsConfigFile(this.projectConfig.targets.test.options.tsConfig, rootTsConfigFile, projectOffsetFromRoot);
        }
        if (this.projectConfig.targets.server) {
            this.updateTsConfigFile(this.projectConfig.targets.server.options.tsConfig, rootTsConfigFile, projectOffsetFromRoot);
        }
    }
    updateEsLintConfig() {
        var _a, _b, _c;
        const eslintConfigPath = (_c = (_b = (_a = this.projectConfig.targets.lint) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.eslintConfig) !== null && _c !== void 0 ? _c : (0, devkit_1.joinPathFragments)(this.project.newRoot, '.eslintrc.json');
        if (!this.tree.exists(eslintConfigPath)) {
            return;
        }
        (0, devkit_1.updateJson)(this.tree, eslintConfigPath, (json) => {
            var _a;
            delete json.root;
            json.ignorePatterns = ['!**/*'];
            const rootEsLintConfigRelativePath = (0, devkit_1.joinPathFragments)((0, devkit_1.offsetFromRoot)(this.projectConfig.root), '.eslintrc.json');
            if (Array.isArray(json.extends)) {
                json.extends = json.extends.map((extend) => this.convertEsLintConfigExtendToNewPath(eslintConfigPath, extend));
                // it might have not been extending from the root config, make sure it does
                if (!json.extends.includes(rootEsLintConfigRelativePath)) {
                    json.extends.push(rootEsLintConfigRelativePath);
                }
            }
            else {
                json.extends = rootEsLintConfigRelativePath;
            }
            (_a = json.overrides) === null || _a === void 0 ? void 0 : _a.forEach((override) => {
                var _a;
                if (!((_a = override.parserOptions) === null || _a === void 0 ? void 0 : _a.project)) {
                    return;
                }
                override.parserOptions.project = [
                    `${this.projectConfig.root}/tsconfig.*?.json`,
                ];
            });
            return json;
        });
    }
    convertBuildOptions(buildOptions) {
        buildOptions.outputPath =
            buildOptions.outputPath &&
                (0, devkit_1.joinPathFragments)('dist', this.project.newRoot);
        buildOptions.index =
            buildOptions.index && this.convertAsset(buildOptions.index);
        buildOptions.main =
            buildOptions.main && this.convertAsset(buildOptions.main);
        buildOptions.polyfills =
            buildOptions.polyfills && this.convertAsset(buildOptions.polyfills);
        buildOptions.tsConfig =
            buildOptions.tsConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.app.json');
        buildOptions.assets =
            buildOptions.assets &&
                buildOptions.assets.map((asset) => this.convertAsset(asset));
        buildOptions.styles =
            buildOptions.styles &&
                buildOptions.styles.map((style) => this.convertAsset(style));
        buildOptions.scripts =
            buildOptions.scripts &&
                buildOptions.scripts.map((script) => this.convertAsset(script));
        buildOptions.fileReplacements =
            buildOptions.fileReplacements &&
                buildOptions.fileReplacements.map((replacement) => ({
                    replace: this.convertAsset(replacement.replace),
                    with: this.convertAsset(replacement.with),
                }));
    }
    convertServerOptions(serverOptions) {
        serverOptions.outputPath =
            serverOptions.outputPath &&
                (0, devkit_1.joinPathFragments)('dist', 'apps', `${this.project.name}-server`);
        serverOptions.main =
            serverOptions.main && this.convertAsset(serverOptions.main);
        serverOptions.tsConfig =
            serverOptions.tsConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.server.json');
        serverOptions.fileReplacements =
            serverOptions.fileReplacements &&
                serverOptions.fileReplacements.map((replacement) => ({
                    replace: this.convertAsset(replacement.replace),
                    with: this.convertAsset(replacement.with),
                }));
    }
    moveFilePathsFromTargetToProjectRoot(target, options) {
        options.forEach((option) => {
            this.getTargetValuesForOption(target, option).forEach((path) => {
                this.moveProjectRootFile(path);
            });
        });
    }
}
exports.AppMigrator = AppMigrator;
//# sourceMappingURL=app.migrator.js.map