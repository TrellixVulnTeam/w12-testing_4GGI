"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.E2eProjectMigrator = void 0;
const tslib_1 = require("tslib");
const cypress_1 = require("@nrwl/cypress");
const devkit_1 = require("@nrwl/devkit");
const linter_1 = require("@nrwl/linter");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const path_1 = require("path");
const project_migrator_1 = require("./project.migrator");
class E2eProjectMigrator extends project_migrator_1.ProjectMigrator {
    constructor(tree, options, project) {
        super(tree, options, project, 'apps');
        this.appConfig = project.config;
        this.appName = this.project.name;
        this.initialize();
    }
    migrate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.project) {
                this.logger.warn('No e2e project was migrated because there was none declared in angular.json.');
                return;
            }
            if (this.isProtractorE2eProject()) {
                yield this.migrateProtractorE2eProject();
            }
            else if (this.isCypressE2eProject()) {
                yield this.migrateCypressE2eProject();
            }
            const tsConfig = (0, devkit_1.joinPathFragments)(this.projectConfig.root, 'tsconfig.json');
            const rootOffset = (0, devkit_1.offsetFromRoot)(this.project.newRoot);
            (0, devkit_1.updateJson)(this.tree, tsConfig, (json) => {
                json.extends = `${rootOffset}${(0, typescript_1.getRootTsConfigPathInTree)(this.tree)}`;
                json.compilerOptions = Object.assign(Object.assign({}, json.compilerOptions), { outDir: `${rootOffset}dist/out-tsc` });
                return json;
            });
        });
    }
    validate() {
        if (!this.project) {
            return null;
        }
        if (this.isProtractorE2eProject()) {
            if (this.tree.exists(this.projectConfig.targets.e2e.options.protractorConfig)) {
                return null;
            }
            return [
                {
                    message: `The "e2e" target is using a Protractor builder but the Protractor config file ` +
                        `"${this.projectConfig.targets.e2e.options.protractorConfig}" could not be found.`,
                    hint: `Make sure the "${this.appName}.architect.e2e.options.protractorConfig" is set to a valid path ` +
                        `or remove the "${this.appName}.architect.e2e" target if it is not valid.`,
                },
            ];
        }
        else if (this.isCypressE2eProject()) {
            const configFile = this.getCypressConfigFile();
            if (configFile && !this.tree.exists(configFile)) {
                return [
                    {
                        message: `The "e2e" target is using a Cypress builder but the Cypress config file "${configFile}" could not be found.`,
                        hint: `Make sure the "${this.appName}.architect.e2e.options.configFile" option is set to a valid path, ` +
                            `or that a "cypress.json" file exists in the workspace root, ` +
                            `or remove the "${this.appName}.architect.e2e" target if it its not valid.`,
                    },
                ];
            }
            if (!this.tree.exists('cypress')) {
                return [
                    {
                        message: `The "e2e" target is using a Cypress builder but the "cypress" directory could not be found.`,
                        hint: 'Make sure the "cypress" directory exists in the workspace root or remove the "e2e" target if it is not valid.',
                    },
                ];
            }
            return null;
        }
        return [
            {
                message: `The "e2e" target is using an unsupported builder "${this.projectConfig.targets.e2e.executor}".`,
                hint: `The supported builders are "@cypress/schematic:cypress" and "@angular-devkit/build-angular:protractor".`,
            },
        ];
    }
    initialize() {
        var _a;
        if (!((_a = this.projectConfig.targets) === null || _a === void 0 ? void 0 : _a.e2e)) {
            this.project = null;
            return;
        }
        this.isProjectUsingEsLint =
            Boolean(this.appConfig.targets.lint) ||
                this.tree.exists((0, devkit_1.joinPathFragments)(this.appConfig.root, '.eslintrc.json'));
        const name = this.project.name.endsWith('-e2e')
            ? this.project.name
            : `${this.project.name}-e2e`;
        const newRoot = (0, devkit_1.joinPathFragments)('apps', name);
        const newSourceRoot = (0, devkit_1.joinPathFragments)('apps', name, 'src');
        if (this.isProtractorE2eProject()) {
            this.project = Object.assign(Object.assign({}, this.project), { name, oldRoot: (0, devkit_1.joinPathFragments)(this.project.oldRoot, 'e2e'), newRoot,
                newSourceRoot });
        }
        else if (this.isCypressE2eProject()) {
            this.project = Object.assign(Object.assign({}, this.project), { name, oldRoot: 'cypress', newRoot,
                newSourceRoot });
        }
    }
    migrateProtractorE2eProject() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.moveDir(this.project.oldRoot, this.project.newRoot);
            this.projectConfig = {
                root: this.project.newRoot,
                projectType: 'application',
                targets: {
                    e2e: Object.assign(Object.assign({}, this.projectConfig.targets.e2e), { options: Object.assign(Object.assign({}, this.projectConfig.targets.e2e.options), { protractorConfig: (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(this.projectConfig.targets.e2e.options.protractorConfig)) }) }),
                },
                implicitDependencies: [this.appName],
                tags: [],
            };
            (0, devkit_1.addProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig), true);
            if (this.isProjectUsingEsLint) {
                yield (0, linter_1.lintProjectGenerator)(this.tree, {
                    project: this.project.name,
                    linter: linter_1.Linter.EsLint,
                    eslintFilePatterns: [`${this.project.newRoot}/**/*.{js,ts}`],
                    tsConfigPaths: [
                        (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.json'),
                    ],
                    skipFormat: true,
                });
            }
            // remove e2e target from the app config
            delete this.appConfig.targets.e2e;
            (0, devkit_1.updateProjectConfiguration)(this.tree, this.appName, Object.assign({}, this.appConfig));
        });
    }
    migrateCypressE2eProject() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const oldCypressConfigFilePath = this.getCypressConfigFile();
            yield (0, cypress_1.cypressProjectGenerator)(this.tree, {
                name: this.project.name,
                project: this.appName,
                linter: this.isProjectUsingEsLint ? linter_1.Linter.EsLint : linter_1.Linter.None,
                standaloneConfig: true,
                skipFormat: true,
            });
            const cypressConfigFilePath = this.updateOrCreateCypressConfigFile(oldCypressConfigFilePath);
            this.updateCypressProjectConfiguration(cypressConfigFilePath);
            // replace the generated tsconfig.json with the project one
            const newTsConfigPath = (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.json');
            this.tree.delete(newTsConfigPath);
            this.moveFile((0, devkit_1.joinPathFragments)(this.project.oldRoot, 'tsconfig.json'), newTsConfigPath);
            // replace the generated source with the project source
            (0, devkit_1.visitNotIgnoredFiles)(this.tree, this.project.newSourceRoot, (filePath) => {
                this.tree.delete(filePath);
            });
            this.moveDir(this.project.oldRoot, (0, devkit_1.joinPathFragments)(this.project.newSourceRoot));
        });
    }
    updateOrCreateCypressConfigFile(configFile) {
        let cypressConfigFilePath;
        if (configFile) {
            cypressConfigFilePath = (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(configFile));
            this.updateCypressConfigFilePaths(configFile);
            this.tree.delete(cypressConfigFilePath);
            this.moveFile(configFile, cypressConfigFilePath);
        }
        else {
            cypressConfigFilePath = (0, devkit_1.joinPathFragments)(this.project.newRoot, 'cypress.json');
            this.tree.write(cypressConfigFilePath, JSON.stringify({
                fileServerFolder: '.',
                fixturesFolder: './src/fixtures',
                integrationFolder: './src/integration',
                modifyObstructiveCode: false,
                supportFile: './src/support/index.ts',
                pluginsFile: './src/plugins/index.ts',
                video: true,
                videosFolder: `../../dist/cypress/${this.project.newRoot}/videos`,
                screenshotsFolder: `../../dist/cypress/${this.project.newRoot}/screenshots`,
                chromeWebSecurity: false,
            }));
        }
        return cypressConfigFilePath;
    }
    updateCypressProjectConfiguration(cypressConfigPath) {
        /**
         * The `cypressProjectGenerator` function normalizes the project name. The
         * migration keeps the names for existing projects as-is to avoid any
         * confusion. The e2e project is technically new, but it's associated
         * to an existing application.
         */
        const generatedProjectName = (0, devkit_1.names)(this.project.name).fileName;
        if (this.project.name !== generatedProjectName) {
            // If the names are different, we "rename" the newly added project.
            this.projectConfig = (0, devkit_1.readProjectConfiguration)(this.tree, generatedProjectName);
            this.projectConfig.root = this.project.newRoot;
            this.projectConfig.sourceRoot = this.project.newSourceRoot;
            (0, devkit_1.removeProjectConfiguration)(this.tree, generatedProjectName);
            (0, devkit_1.addProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig), true);
        }
        else {
            this.projectConfig = (0, devkit_1.readProjectConfiguration)(this.tree, this.project.name);
        }
        if (this.isProjectUsingEsLint) {
            this.projectConfig.targets.lint.options.lintFilePatterns =
                this.projectConfig.targets.lint.options.lintFilePatterns.map((pattern) => pattern.replace(`apps/${generatedProjectName}`, this.project.newRoot));
        }
        ['e2e', 'cypress-run', 'cypress-open'].forEach((target) => {
            if (this.appConfig.targets[target]) {
                this.projectConfig.targets[target] = this.updateE2eCypressTarget(this.appConfig.targets[target], this.projectConfig.targets[target], cypressConfigPath);
            }
        });
        (0, devkit_1.updateProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig));
        delete this.appConfig.targets['cypress-run'];
        delete this.appConfig.targets['cypress-open'];
        delete this.appConfig.targets.e2e;
        (0, devkit_1.updateProjectConfiguration)(this.tree, this.appName, Object.assign({}, this.appConfig));
    }
    updateE2eCypressTarget(existingTarget, generatedTarget, cypressConfig) {
        const updatedTarget = Object.assign(Object.assign({}, existingTarget), { executor: '@nrwl/cypress:cypress', options: Object.assign(Object.assign({}, existingTarget.options), { cypressConfig }) });
        delete updatedTarget.options.configFile;
        if (generatedTarget &&
            !generatedTarget.options.tsConfig &&
            updatedTarget.options.tsConfig) {
            // if what we generate doesn't have a tsConfig, we don't need it
            delete updatedTarget.options.tsConfig;
        }
        else if (updatedTarget.options.tsConfig) {
            updatedTarget.options.tsConfig = (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.json');
        }
        if (updatedTarget.options.headless && updatedTarget.options.watch) {
            updatedTarget.options.headed = false;
        }
        else if (updatedTarget.options.headless === false &&
            !updatedTarget.options.watch) {
            updatedTarget.options.headed = true;
        }
        delete updatedTarget.options.headless;
        return updatedTarget;
    }
    updateCypressConfigFilePaths(configFilePath) {
        const srcFoldersAndFiles = [
            'integrationFolder',
            'supportFile',
            'pluginsFile',
            'fixturesFolder',
        ];
        const distFolders = ['videosFolder', 'screenshotsFolder'];
        const stringOrArrayGlobs = ['ignoreTestFiles', 'testFiles'];
        const cypressConfig = (0, devkit_1.readJson)(this.tree, configFilePath);
        cypressConfig.fileServerFolder = '.';
        srcFoldersAndFiles.forEach((folderOrFile) => {
            if (cypressConfig[folderOrFile]) {
                cypressConfig[folderOrFile] = `./src/${(0, path_1.relative)(this.project.oldRoot, cypressConfig[folderOrFile])}`;
            }
        });
        distFolders.forEach((folder) => {
            if (cypressConfig[folder]) {
                cypressConfig[folder] = `../../dist/cypress/${this.project.newRoot}/${(0, path_1.relative)(this.project.oldRoot, cypressConfig[folder])}`;
            }
        });
        stringOrArrayGlobs.forEach((stringOrArrayGlob) => {
            if (!cypressConfig[stringOrArrayGlob]) {
                return;
            }
            if (Array.isArray(cypressConfig[stringOrArrayGlob])) {
                cypressConfig[stringOrArrayGlob] = cypressConfig[stringOrArrayGlob].map((glob) => this.replaceCypressGlobConfig(glob));
            }
            else {
                cypressConfig[stringOrArrayGlob] = this.replaceCypressGlobConfig(cypressConfig[stringOrArrayGlob]);
            }
        });
        (0, devkit_1.writeJson)(this.tree, configFilePath, cypressConfig);
    }
    replaceCypressGlobConfig(globPattern) {
        return globPattern.replace(new RegExp(`^(\\.\\/|\\/)?${this.project.oldRoot}\\/`), './src/');
    }
    getCypressConfigFile() {
        let cypressConfig = 'cypress.json';
        const configFileOption = this.projectConfig.targets.e2e.options.configFile;
        if (configFileOption === false) {
            cypressConfig = undefined;
        }
        else if (typeof configFileOption === 'string') {
            cypressConfig = (0, path_1.basename)(configFileOption);
        }
        return cypressConfig;
    }
    isCypressE2eProject() {
        return (this.projectConfig.targets.e2e.executor === '@cypress/schematic:cypress');
    }
    isProtractorE2eProject() {
        return (this.projectConfig.targets.e2e.executor ===
            '@angular-devkit/build-angular:protractor');
    }
}
exports.E2eProjectMigrator = E2eProjectMigrator;
//# sourceMappingURL=e2e.migrator.js.map